#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Time    : 2020/9/26 0026 20:23
# @Author  : Cojun  Mao
# @Site    : 
# @File    : fields.py
# @Project : mysite_diy
# @Software: PyCharm
import builtins
import decimal
import itertools
import time

from datetime import datetime

text_type = str
bytes_type = bytes
buffer_type = memoryview
basestring = str
long = int
multi_types = (list, tuple, frozenset, set, range)
print_ = getattr(builtins, 'print')
izip_longest = itertools.zip_longest

class Field:
    field_type = 'DEFAULT'

    def __init__(self, column_name=None, primary_key=False, default=None, unique=False, help_text=None):
        """

        :param column_name: 字段名
        :param primary_key: 字段是否作为主键
        :param default: 字段的默认值
        :param unique: 字段值是否唯一
        :param help_text: 字段说明文本
        """
        self.name = column_name  # 字段名
        self.primary_key = primary_key  # 该字段是否作为主键
        self.default = default  # 该字段的默认值
        self.unique = unique  # 该字段值是否唯一
        self.help_text = help_text  # 字段说明文本

    def adapt(self, value):
        return value

    def to_db_value(self, value):
        """ 将输入值转换为预期的数据库数据类型，返回转换后的值。子类应该覆盖这个。              """
        return value if value is None else self.adapt(value)

    def to_python_value(self, value):
        """ 将输入值转换为预期的Python数据类型，返回转换后的值。子类应该覆盖这个。              """
        return value if value is None else self.adapt(value)

    def ddl_datatype(self, ctx):
        if ctx and ctx.state.field_types:
            column_type = ctx.state.field_types.get(self.field_type,
                                                    self.field_type)
        else:
            column_type = self.field_type

        modifiers = self.get_modifiers()
        if column_type and modifiers:
            modifier_literal = ', '.join([str(m) for m in modifiers])
            return '%s(%s)' % (column_type, modifier_literal)
        else:
            return column_type


# 字符串类型，默认 varchar(100)
class StringField(Field):
    pass
# Bool类型, 无法作为主键，primary属性直接赋值False
class BooleanField(Field):
    pass

# 整数类型
class IntegerField(Field):
    field_type = 'INT'


# 浮点类型
class FloatField(Field):
    field_type = 'FLOAT'

    def adapt(self, value):
        try:
            return float(value)
        except ValueError:
            return value


class DoubleField(FloatField):
    field_type = 'DOUBLE'


# 长文本类型
class TextField(Field):
    field_type = 'TEXT'


class IntegerField(Field):
    field_type = 'INT'

    def adapt(self, value):
        try:
            return int(value)
        except ValueError:
            return value


class BigIntegerField(IntegerField):
    field_type = 'BIGINT'


class SmallIntegerField(IntegerField):
    field_type = 'SMALLINT'


class AutoField(IntegerField):
    auto_increment = True
    field_type = 'AUTO'

    def __init__(self, *args, **kwargs):
        if kwargs.get('primary_key') is False:
            raise ValueError('%s must always be a primary key.' % type(self))
        kwargs['primary_key'] = True
        super(AutoField, self).__init__(*args, **kwargs)


class BigAutoField(AutoField):
    field_type = 'BIGAUTO'


class IdentityField(AutoField):
    field_type = 'INT GENERATED BY DEFAULT AS IDENTITY'

    def __init__(self, generate_always=False, **kwargs):
        if generate_always:
            self.field_type = 'INT GENERATED ALWAYS AS IDENTITY'
        super(IdentityField, self).__init__(**kwargs)


class DecimalField(Field):
    field_type = 'DECIMAL'

    def __init__(self, max_digits=10, decimal_places=5, auto_round=False,
                 rounding=None, *args, **kwargs):
        self.max_digits = max_digits
        self.decimal_places = decimal_places
        self.auto_round = auto_round
        self.rounding = rounding or decimal.DefaultContext.rounding
        self._exp = decimal.Decimal(10) ** (-self.decimal_places)
        super(DecimalField, self).__init__(*args, **kwargs)

    def get_modifiers(self):
        return [self.max_digits, self.decimal_places]

    def db_value(self, value):
        D = decimal.Decimal
        if not value:
            return value if value is None else D(0)
        if self.auto_round:
            decimal_value = D(text_type(value))
            return decimal_value.quantize(self._exp, rounding=self.rounding)
        return value

    def python_value(self, value):
        if value is not None:
            if isinstance(value, decimal.Decimal):
                return value
            return decimal.Decimal(text_type(value))


class CharField(Field):
    field_type = 'VARCHAR'

    def __init__(self, max_length=255, *args, **kwargs):
        self.max_length = max_length
        super().__init__(*args, **kwargs)

    def get_modifiers(self):
        return self.max_length and [self.max_length] or None

class DateTimeField(Field):
    db_field = 'datetime'

    def python_value(self, value):
        if value is not None:
            value = value.rsplit('.', 1)[0]
            return datetime(*time.strptime(value, '%Y-%m-%d %H:%M:%S')[:6])
