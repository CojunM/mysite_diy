#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time    : 2020/9/26 0026 19:59# @Author  : Cojun  Mao# @Site    : # @File    : simpletemplate.py# @Project : mysite_diy# @Software: PyCharmimport functoolsimport osimport reimport warningsfrom brick.utils.cachehelper import cached_propertyfrom brick.utils.encode import tounicodefrom brick.utils.htmlescape import html_escapeDEBUG = False# './' 代表当前所在目录下的某个文件夹或文件TEMPLATE_PATH = ['./', './html/', './html/admin/']TEMPLATES = {}from brick.core.httphelper.response import HTTPErrordef depr(major, minor, cause, fix):    text = "Warning: Use of deprecated feature or API. (Deprecated in Bottle-%d.%d)\n" \           "Cause: %s\n" \           "Fix: %s\n" % (major, minor, cause, fix)    if DEBUG == 'strict':        raise DeprecationWarning(text)    warnings.warn(text, DeprecationWarning, stacklevel=3)    return DeprecationWarning(text)class TemplateError(HTTPError):    def __init__(self, message):        HTTPError.__init__(self, 500, message)class BaseTemplate(object):    """ 模板适配器的基类和最小API"""    extensions = ['tpl', 'html', 'thtml', 'stpl']    settings = {}  # used in prepare()    defaults = {}  # used in render()    def __init__(self,                 source=None,                 name=None,                 lookup=None,                 encoding='utf8', **settings):        """ 创建新模板。            如果缺少源参数（str或buffer），则name参数            用于猜测模板文件名。子类可以假设            自身来源和/或self.filename文件名已设置。两者都是弦。            查找、编码和设置参数存储为实例            变量。            lookup参数存储包含目录路径的列表。            编码参数应用于解码字节字符串或文件。            settings参数包含特定于引擎设置的dict。            """        self.name = name        self.source = source.read() if hasattr(source, 'read') else source        self.filename = source.filename if hasattr(source, 'filename') else None        self.lookup = [os.path.abspath(x) for x in lookup] if lookup else []        self.encoding = encoding        self.settings = self.settings.copy()  # Copy from class variable        self.settings.update(settings)  # Apply        if not self.source and self.name:            self.filename = self.search(self.name, self.lookup)            if not self.filename:                raise TemplateError('Template %s not found.' % repr(name))        if not self.source and not self.filename:            raise TemplateError('No template specified.')        self.prepare(**self.settings)    @classmethod    def search(cls, name, lookup=None):        """ 在查找中指定的所有目录中搜索名称。先没有，然后有共同的扩展。返回第一次命中. """        if not lookup:            raise depr(0, 12, "Empty template lookup path.", "Configure a template lookup path.")        if os.path.isabs(name):            raise depr(0, 12, "Use of absolute path for template name.",                       "Refer to template with names or paths relative to the lookup path.")        for spath in lookup:            spath = os.path.abspath(spath) + os.sep            fname = os.path.abspath(os.path.join(spath, name))            if not fname.startswith(spath): continue            if os.path.isfile(fname): return fname            for ext in cls.extensions:                if os.path.isfile('%s.%s' % (fname, ext)):                    return '%s.%s' % (fname, ext)    @classmethod    def global_config(cls, key, *args):        """ 这将读取或设置存储在中的全局设置类设置. """        if args:            cls.settings = cls.settings.copy()  # Make settings local to class            cls.settings[key] = args[0]        else:            return cls.settings[key]    def prepare(self, **options):        """ 运行准备（解析、缓存…）。            应该可以再次调用此命令以刷新模板或            更新设置。            """        raise NotImplementedError    def render(self, *args, **kwargs):        """ 使用指定的局部变量呈现模板并返回            单字节或unicode字符串。如果是字节字符串，则编码            必须匹配自我编码. 此方法必须是线程安全的！            局部变量可以在字典（arg）中提供            或者直接作为关键字（kwargs）。            """        raise NotImplementedErrorclass StplParser(object):    """ Parser for stpl template. """    _re_cache = {}  #: Cache for compiled re patterns    # This huge pile of voodoo magic splits python code into 8 different tokens.    # We use the verbose (?x) regex mode to make this more manageable    _re_tok = r'''(        # verbose and dot-matches-newline mode              [urbURB]*            (?:  ''(?!')                |""(?!")                |'{6}                |"{6}                |'(?:[^\\']|\\.)+?'                |"(?:[^\\"]|\\.)+?"                |'{3}(?:[^\\]|\\.|\n)+?'{3}                |"{3}(?:[^\\]|\\.|\n)+?"{3}            )        )'''    _re_inl = _re_tok.replace(r'|\n', '')  # We re-use this string pattern later    _re_tok += r'''            # 2: Comments (until end of line, but not the newline itself)            |(\#.*)            # 3: Open and close (4) grouping tokens            |([\[\{\(])            |([\]\}\)])            # 5,6: Keywords that start or continue a python block (only start of line)            |^([\ \t]*(?:if|for|while|with|try|def|class)\b)            |^([\ \t]*(?:elif|else|except|finally)\b)            # 7: Our special 'end' keyword (but only if it stands alone)            |((?:^|;)[\ \t]*end[\ \t]*(?=(?:%(block_close)s[\ \t]*)?\r?$|;|\#))            # 8: A customizable end-of-code-block template token (only end of line)            |(%(block_close)s[\ \t]*(?=\r?$))            # 9: And finally, a single newline. The 10th token is 'everything else'            |(\r?\n)        '''    # (?mx)m匹配多行，同时x忽视正则表达式中的空格和换行（且开启注释功能）    _re_tok = r'''(?mx)  %s ''' % _re_tok    # 匹配模板中代码区域的起始标记    _re_split = r'''(?m)^[ \t]*(\\?)((%(line_start)s)|(%(block_start)s))'''    # 匹配内联语句（可能包含python字符串）    _re_inl = r'''(?mx) %%(inline_start)s((?:%s|[^'"\n]+?)*?)%%(inline_end)s''' % _re_inl    default_syntax = '<% %> % {{ }}'    def __init__(self, source, syntax=None, encoding='utf8'):        self.source, self.encoding = tounicode(source, encoding), encoding        self.set_syntax(syntax or self.default_syntax)        self.code_buffer, self.text_buffer = [], []        self.indent, self.indent_mod, self.offset = 0, 0, 0        self.indent, self.offset = 0, 0        self.paren_depth = 0    def get_syntax(self):        """ 作为空格分隔字符串的标记（默认值：<%%>%{{}}） """        return self._syntax    def set_syntax(self, syntax):        self._syntax = syntax        self._tokens = syntax.split()        if syntax not in self._re_cache:            names = 'block_start block_close line_start inline_start inline_end'            etokens = map(re.escape, self._tokens)            pattern_vars = dict(zip(names.split(), etokens))            patterns = (self._re_split, self._re_tok, self._re_inl)            patterns = [re.compile(p % pattern_vars) for p in patterns]            self._re_cache[syntax] = patterns        self.re_split, self.re_tok, self.re_inl = self._re_cache[syntax]        # print('re_split:', self.re_split)    syntax = property(get_syntax, set_syntax)    def translate(self):        if self.offset: raise RuntimeError('Parser is a one time instance.')        while True:            m = self.re_split.search(self.source, pos=self.offset)            # re_split: re.compile('(?m)^[ \\t]*(\\\\?)((%)|(<%))', re.MULTILINE)            if m:                text = self.source[self.offset:m.start()]                self.text_buffer.append(text)  # 将普通html代码存入text_buffer                self.offset = m.end()                if m.group(1):  # Escape syntax                    line, sep, _ = self.source[self.offset:].partition('\n')                    self.text_buffer.append(self.source[m.start():m.start(1)] +                                            m.group(2) + line + sep)                    self.offset += len(line + sep)                    continue                self.flush_text()  # 在(%)|(<%)之前的text中搜索inline code{{}}并存入code_buffer                self.offset += self.read_code(self.source[self.offset:],                                              multiline=bool(m.group(4)))  # 解析%当行的code并存入code_buffer            else:                break        self.text_buffer.append(self.source[self.offset:])        self.flush_text()  # 在(余下的中搜索inline code{{}}并存入code_buffer        return ''.join(self.code_buffer)    def read_code(self, pysource, multiline):        code_line, comment = '', ''        offset = 0        # re_tok = re.compile(        #     '(?m)([urbURB]?(?:\'\'(?!\')|""(?!")|\'{6}|"{6}|\'(?:[^\\\\\']|\\\\.)+?\''        #     '|"(?:[^\\\\"]|\\\\.)+?"|\'{3}(?:[^\\\\]|\\\\.|\\n)+?\'{3}|"{3}(?:[^\\\\]'        #     '|\\\\.|\\n)+?"{3}))|(#.*)|([\\[\\{\\(])|([\\]\\}\\)])|^([ \t]*(?:if|for'        #     '|while|with|try|def|class)\b)|^([ \t]*(?:elif|else|except|finally)\b)|((?:^'        #     '|;)[ \t]*end[ \t]*(?=(?:%>[ \t]*)?\r?$|;|#))|(%>[ \t]*(?=\r?$))|(\r?\n)'        #     '', re.MULTILINE)        while True:            m = self.re_tok.search(pysource, pos=offset)            if not m:  # 没有，就将文本写入code_buffer                code_line += pysource[offset:]                offset = len(pysource)                self.write_code(code_line.strip(), comment)                break            code_line += pysource[offset:m.start()]            offset = m.end()            _str, _com, _po, _pc, _blk1, _blk2, _end, _cend, _nl = m.groups()            if self.paren_depth > 0 and (_blk1 or _blk2):  # (a if b else c)                code_line += _blk1 or _blk2                continue            if _str:  # Python string                code_line += _str            elif _com:  # Python comment (up to EOL)                comment = _com                if multiline and _com.strip().endswith(self._tokens[1]):                    multiline = False  # Allow end-of-block in comments            elif _po:  # open parenthesis                self.paren_depth += 1                code_line += _po            elif _pc:  # close parenthesis                if self.paren_depth > 0:                    # we could check for matching parentheses here, but it's                    # easier to leave that to python - just check counts                    self.paren_depth -= 1                code_line += _pc            elif _blk1:  # Start-block keyword (if/for/while/def/try/...)                code_line, self.indent_mod = _blk1, -1                self.indent += 1            elif _blk2:  # Continue-block keyword (else/elif/except/...)                code_line, self.indent_mod = _blk2, -1            elif _end:  # The non-standard 'end'-keyword (ends a block)                self.indent -= 1            elif _cend:  # The end-code-block template token (usually '%>')                if multiline:                    multiline = False                else:                    code_line += _cend            else:  # \n                self.write_code(code_line.strip(), comment)                code_line, comment, self.indent_mod = '', '', 0                if not multiline:                    break        return offset    def flush_text(self):        """在text中搜索inline code{{}}并存入code_buffer"""        text = ''.join(self.text_buffer)        del self.text_buffer[:]        if not text: return        parts, pos, nl = [], 0, '\\\n' + '  ' * self.indent        #  re_inl = re.compile('(?m)\\{\\{((?:([urbURB]?(?:\'\'(?!\')|""(?!")|\'{6}|"{6}        #  |\'(?:[^\\\\\']|\\\\.)+?\'|"(?:[^\\\\"]|\\\\.)+?"|\'{3}(?:[^\\\\]|\\\\.)+?\'{3}        #  |"{3}(?:[^\\\\]|\\\\.)+?"{3}))|[^\'"\n]*?)+)\\}\\}', re.MULTILINE)        for m in self.re_inl.finditer(text):            prefix, pos = text[pos:m.start()], m.end()            if prefix:                parts.append(nl.join(map(repr, prefix.splitlines(True))))            if prefix.endswith('\n'): parts[-1] += nl            parts.append(self.process_inline(m.group(1).strip()))        if pos < len(text):            prefix = text[pos:]            lines = prefix.splitlines(True)            if lines[-1].endswith('\\\\\n'):                lines[-1] = lines[-1][:-3]            elif lines[-1].endswith('\\\\\r\n'):                lines[-1] = lines[-1][:-4]            parts.append(nl.join(map(repr, lines)))        code = '_printlist((%s,))' % ', '.join(parts)        # self.lineno += code.count('\n') + 1        self.write_code(code)    @staticmethod    def process_inline(chunk):        """检测 '!'是否需要转换"""        if chunk[0] == '!': return '_str(%s)' % chunk[1:]        return '_escape(%s)' % chunk    def write_code(self, line, comment=''):        code = '  ' * (self.indent + self.indent_mod)        code += line.lstrip() + comment + '\n'        self.code_buffer.append(code)class SimpleTemplate(BaseTemplate):    def prepare(self,                escape_func=html_escape,                noescape=False,                syntax=None, **ka):        self.cache = {}        enc = self.encoding        self._str = lambda x: tounicode(x, enc)        self._escape = lambda x: escape_func(tounicode(x, enc))        self.syntax = syntax        if noescape:            self._str, self._escape = self._escape, self._str    @cached_property    def co(self):        return compile(self.code, self.filename or '<string>', 'exec')    @cached_property    def code(self):        source = self.source        if not source:            with open(self.filename, 'rb') as f:                source = f.read()        try:            source = tounicode(source)        except UnicodeError:            raise depr(0, 11, 'Unsupported template encodings.', 'Use utf-8 for template.')        parser = StplParser(source, encoding='utf8', syntax=self.syntax)        code = parser.translate()        self.encoding = parser.encoding        return code    def _rebase(self, _env, _name=None, **kwargs):        _env['_rebase'] = (_name, kwargs)    def _include(self, _env, _name=None, **kwargs):        env = _env.copy()        env.update(kwargs)        if _name not in self.cache:            self.cache[_name] = self.__class__(name=_name, lookup=self.lookup, syntax=self.syntax)        return self.cache[_name].execute(env['_stdout'], env)    def execute(self, _stdout, kwargs):        env = self.defaults.copy()        env.update(kwargs)        env.update({            '_stdout': _stdout,            '_printlist': _stdout.extend,            'include': functools.partial(self._include, env),            'rebase': functools.partial(self._rebase, env),            '_rebase': None,            '_str': self._str,            '_escape': self._escape,            'get': env.get,            'setdefault': env.setdefault,            'defined': env.__contains__        })        exec(self.co, env)        if env.get('_rebase'):            subtpl, rargs = env.pop('_rebase')            rargs['base'] = ''.join(_stdout)  # copy stdout            del _stdout[:]  # clear stdout            return self._include(env, subtpl, **rargs)        return env    def render(self, *args, **kwargs):        """ Render the template using keyword arguments as local variables. """        env = {}        stdout = []        for dictarg in args:            env.update(dictarg)        env.update(kwargs)        self.execute(stdout, env)        return ''.join(stdout)def template(*args, **kwargs):    """ 获取作为字符串迭代器的呈现模板。        可以使用名称、文件名或模板字符串作为第一个参数。        模板呈现参数可以作为字典传递        或者直接（作为关键字参数）。        """    tpl = args[0] if args else None    for dictarg in args[1:]:        if isinstance(dictarg, dict):            kwargs.update(dictarg)    adapter = kwargs.pop('template_adapter', SimpleTemplate)    lookup = kwargs.pop('template_lookup', TEMPLATE_PATH)    tplid = (id(lookup), tpl)    if tplid not in TEMPLATES or DEBUG:        settings = kwargs.pop('template_settings', {})        if isinstance(tpl, adapter):            TEMPLATES[tplid] = tpl            if settings: TEMPLATES[tplid].prepare(**settings)        elif "\n" in tpl or "{" in tpl or "%" in tpl or '$' in tpl:            TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings)        else:            TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings)    if not TEMPLATES[tplid]:        abort(500, 'Template (%s) not found' % tpl)    return TEMPLATES[tplid].render(kwargs)def abort(code=500, text='Unknown Error.'):    """ Aborts execution and causes a HTTP error. """    raise HTTPError(code, text)if __name__ == "__main__":    # StplParser = StplParser('Hello {{name}}!')    message = """% name = "aBobc"  # a line of python code    <p>Some plain text in between</p>    <%      # A block of python code      name = name.strip("B"  if name else "o")    %>             <p><img src="/images/linuxyw.png"></img></p>         <p>Some plain text in between</p>            %for i in range(3):            %for j in range(3):                {{"%s:%s"%(i,j)}}            %end            %end      <%      # A block of python code      name = name.title().strip()    %>    <ul>    <li>    {{name if name else "stranger"}}         </li>     </ul>    """    t5 = SimpleTemplate(message)    print(t5.render())